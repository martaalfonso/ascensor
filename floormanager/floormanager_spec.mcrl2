sort Floor = Int; % floors as natural numbers 1..3

map
  nextFloor: Floor # Floor -> Floor; % declare a function in which we pass two floors, we get a floor in return. Will calculate the next floor we move to.

var
  c, t: Floor; %variables: current floor, target floor

eqn %we define the logic to move to the next floor
  % if target > current, go up
  nextFloor(c,t) = if(c < t, c+1, %if current floor is smaller than target floor, move one floor up
                  if(c > t, c-1,  %if current floor is bigger than target floor, move one floor down
                          c));

act request,move,detect: Int; %declare actions  with parameter
act stop;					  %declare action without parameter

proc Elevator(c: Floor) = %behavior of the elevator with parameter c of sort Floor
  sum r: Floor. (r <= 10 && r >= 1) -> request(r) . Travel(c, r); %sum goes over all possible values of r of type Floor. "For all possible values of Floor between 1 and 10. -> "if the said condition holds, do what's next": the action request(r) can only happen if the condition of 10>r>1 is valid. request and travel are a sequential composition because of "." in between. So perform request(r) then move to the travel process

proc Travel(c: Floor, t: Floor) = %define Travel process with parameters c and t of sort Floor
  (c == t) -> detect(c) . stop . Elevator(c) % ->if c=t, then do the sequence of actions detect.stop.move to Elevator process to wait for new requests 
+
  (c != t) -> move(nextFloor(c,t)) . %if c is still different from target floor, move one floor up/down accordingly.
              detect(nextFloor(c,t)) . %check the floor again
              Travel(nextFloor(c,t), t); %recurse, loop over again. nextFloor(c,t) updates current floor, t passes the same target floor again

init Elevator(1); % start at floor 1
